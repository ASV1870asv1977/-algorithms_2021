"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""


from timeit import timeit


def simple(i):
    """
    Без использования «Решета Эратосфена»
    Сложность: O(n**2)
    """
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def erato(serial):
    """
    С использованием «Решета Эратосфена»
    Сложность: O(n * log(log n))
    """
    n = serial * 10
    a = [val for val in range(n + 1)]
    a[1] = 0
    i = 2
    while i <= n:
        if a[i] != 0:
            j = i + i
            while j <= n:
                a[j] = 0
                j = j + i
        i += 1

    a = set(a)
    a.remove(0)
    a = sorted(list(a))
    return a[serial - 1]


if __name__ == '__main__':
    while True:
        str_label = "=" * 20
        print(f'{str_label} ЭРАТОСФЕН {str_label}')
        i = input(f'Для выхода введите "0"\n'
                  f'Введите порядковый номер искомого простого числа: ')
        try:
            i = int(i)
        except ValueError:
            print('Не введено численное значение!!!')
            continue

        if i == 0:
            print('Выход')
            break

        print('-' * 50)
        print(f'Простой способ.      Число: {simple(i)}. '
              f'Выполнение: {timeit("simple(i)", globals=globals(), number=100)}')
        print(f'"Решето Эратосфена". Число: {erato(i)}. '
              f'Выполнение: {timeit("erato(i)", globals=globals(), number=100)}\n')

"""
Исходя из полученных результатов замеров и сложностей примененных алгоритмов можно сделать вывод,
что при малых значениях порядкового числа "простой" алгоритм выигрывает, но при увеличении 
порядкового числа его время выполнения квадротично увеличивается. В то время как алгоритм "Эратосфена"
при малых количествах операций сильно проигрывает "простому" алгоритму, но с увеличением количества 
операций прирост времени выполнения становится незначительным.

Математически я могу обосновать данные результаты тем, что в "простом" алгоритме со сложностью O(n**2) 
график роста "О-большое" развивается по параболе с вершиной ориентированной по оси "Операции", 
а в алгоритме "Эратосфена" со сложностью O(n * log(log n)) график роста "О-большое" развивается 
по параболе с вершиной ориентированной по оси "Количество элементов".

Точка пересечения парабол приходится на вычислении 14-15-го (43, 47) простого числа.
"""













